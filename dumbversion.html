<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pace Assigner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/javascript-lp-solver/prod/solver.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'secondary': '#f97316',
                        'background': '#f3f4f6',
                        'card': '#ffffff',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        br {
            display: block; /* makes it have a width */
            content: ""; /* clears default height */
            margin-top: .25rem; /* change this to whatever height you want it */
        }
        .pace-checkbox:checked+label {
            background-color: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        .success {
            color: #10b981;
        }

        .error {
            color: #ef4444;
        }

        .tab-inactive {
            background-color: #e5e7eb;
            color: #4b5563;
        }

        .validation-border {
            border: 1px solid #ef4444 !important;
        }

        /* --- Custom Responsive Table Styles --- */

        /* Global fix for pace preference height (applies to all views) */
        .pace-container {
            /* Max height equivalent to roughly 3 lines of text-xs badges (~4.5rem/72px) */
            max-height: 4.5rem;
            overflow-y: auto;
            padding-right: 0.5rem;
            /* Space for scrollbar */
            /* Ensure the content is not wrapped and stays on the left */
            align-items: flex-start;
            align-content: flex-start;
        }

        /* Mobile (Default: below sm breakpoint) Card View Transformation */
        @media (max-width: 640px) {
            #runners-table {
                /* Ensure table takes full width but allows styling on rows */
                display: block;
            }

            #runners-table thead {
                /* Hide the table headers on mobile */
                display: none;
            }

            #runners-table tr {
                /* Make each row look like a block/card */
                display: grid;
                grid-template-columns: 1fr;
                gap: 0.5rem;
                padding: 1rem;
                margin-bottom: 1rem;
                border: 1px solid #e5e7eb;
                border-radius: 0.75rem;
                background-color: white;
                position: relative;
                /* For absolute positioning of delete button */
                box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            }

            #runners-table td {
                display: flex;
                align-items: center;
                padding: 0;
                /* Remove default padding */
                border: none;
                width: 100%;
                /* Ensure all cells take full card width */
            }

            /* Add labels to cells (tds) on mobile for clarity and order */
            #runners-table td:nth-child(1) {
                order: -2;
                justify-content: flex-start;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid #f3f4f6;
            }

            #runners-table td:nth-child(1) .text-sm::before {
                content: 'Runner #';
                font-weight: 600;
                margin-right: 0.5rem;
                color: #4f46e5;
            }

            #runners-table td:nth-child(2) {
                order: 1;
                flex-direction: column;
                align-items: flex-start;
            }

            #runners-table td:nth-child(2)::before {
                content: 'Runner Name';
                font-weight: 600;
                margin-bottom: 0.25rem;
                color: #4f46e5;
            }

            #runners-table td:nth-child(3) {
                order: 2;
            }

            #runners-table td:nth-child(3) input {
                text-align: left;
            }

            #runners-table td:nth-child(3)::before {
                content: 'Seniority (1 = Most)';
                font-weight: 600;
                margin-right: 0.5rem;
                color: #4f46e5;
            }

            #runners-table td:nth-child(4) {
                order: 3;
                flex-direction: column;
                align-items: flex-start;
            }

            #runners-table td:nth-child(4)::before {
                content: 'Pace Preferences (min/mile)';
                font-weight: 600;
                margin-bottom: 0.25rem;
                color: #4f46e5;
            }

            #runners-table td:nth-child(5) {
                order: 4;
                justify-content: space-between;
                padding-top: 0.5rem;
                border-top: 1px solid #f3f4f6;
            }

            #runners-table td:nth-child(5) .sr-only {
                display: block;
            }

            /* Show Active label for mobile card */

            #runners-table td:nth-child(6) {
                order: -1;
                justify-content: flex-end;
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                width: auto;
            }

            /* Delete button */

            /* Full width for inputs inside the card to maximize space */
            .runner-name,
            .runner-seniority {
                width: 100%;
            }

            /* Hide the sr-only element on desktop */
            #runners-table td:nth-child(5) label .sr-only {
                display: none;
            }
        }

        /* Desktop/Tablet (sm: and up) column widths (ensure good proportions) */
        @media (min-width: 641px) {
            .runner-name-col {
                width: 25%;
            }

            /* More space for name */
            .seniority-col {
                width: 10%;
            }

            /* Reduced space for seniority */
            .pace-prefs-col {
                width: 45%;
            }

            /* Max space for paces */
            .active-col {
                width: 5%;
            }

            .action-col {
                width: 10%;
            }

            /* Ensure table cells have correct alignment on desktop */
            #runners-table td:nth-child(2) {
                text-align: left;
            }

            #runners-table td:nth-child(3) {
                text-align: center;
            }

            #runners-table td:nth-child(4) {
                text-align: left;
            }
        }

    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:Inter, sans-serif;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.relative{position:relative}.m-0\.5{margin:0.125rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mb-8{margin-bottom:2rem}.mt-2{margin-top:0.5rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.ml-3{margin-left:0.75rem}.inline-block{display:inline-block}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-full{height:100%}.min-h-screen{min-height:100vh}.w-\[5\%\]{width:5%}.w-full{width:100%}.w-11{width:2.75rem}.w-5{width:1.25rem}.min-w-full{min-width:100%}.max-w-6xl{max-width:72rem}.cursor-pointer{cursor:pointer}.cursor-not-allowed{cursor:not-allowed}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:1rem}.space-x-2 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(0.5rem * var(--tw-space-x-reverse));margin-left:calc(0.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-2 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.5rem * var(--tw-space-y-reverse))}.space-y-4 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-x-1 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(0.25rem * var(--tw-space-x-reverse));margin-left:calc(0.25rem * calc(1 - var(--tw-space-x-reverse)))}.divide-y > :not([hidden]) ~ :not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.divide-gray-200 > :not([hidden]) ~ :not([hidden]){--tw-divide-opacity:1;border-color:rgb(229 231 235 / var(--tw-divide-opacity, 1))}.overflow-x-auto{overflow-x:auto}.whitespace-nowrap{white-space:nowrap}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.rounded-xl{border-radius:0.75rem}.rounded-full{border-radius:9999px}.rounded-t-lg{border-top-left-radius:0.5rem;border-top-right-radius:0.5rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-l-4{border-left-width:4px}.border-gray-100{--tw-border-opacity:1;border-color:rgb(243 244 246 / var(--tw-border-opacity, 1))}.border-primary{--tw-border-opacity:1;border-color:rgb(79 70 229 / var(--tw-border-opacity, 1))}.border-red-500{--tw-border-opacity:1;border-color:rgb(239 68 68 / var(--tw-border-opacity, 1))}.border-transparent{border-color:transparent}.border-gray-300{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.bg-background{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.bg-card{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-gray-50{--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))}.bg-primary{--tw-bg-opacity:1;background-color:rgb(79 70 229 / var(--tw-bg-opacity, 1))}.bg-secondary{--tw-bg-opacity:1;background-color:rgb(249 115 22 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-gray-100{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.bg-gray-200{--tw-bg-opacity:1;background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))}.bg-primary\/20{background-color:rgb(79 70 229 / 0.2)}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-1{padding:0.25rem}.p-2{padding:0.5rem}.px-3{padding-left:0.75rem;padding-right:0.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:0.25rem;padding-bottom:0.25rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.px-2{padding-left:0.5rem;padding-right:0.5rem}.py-0\.5{padding-top:0.125rem;padding-bottom:0.125rem}.pb-3{padding-bottom:0.75rem}.pb-2{padding-bottom:0.5rem}.text-left{text-align:left}.text-center{text-align:center}.font-sans{font-family:Inter, sans-serif}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xs{font-size:0.75rem;line-height:1rem}.font-bold{font-weight:700}.font-extrabold{font-weight:800}.font-medium{font-weight:500}.font-semibold{font-weight:600}.font-normal{font-weight:400}.uppercase{text-transform:uppercase}.tracking-wider{letter-spacing:0.05em}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity, 1))}.text-gray-700{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.text-gray-800{--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity, 1))}.text-gray-900{--tw-text-opacity:1;color:rgb(17 24 39 / var(--tw-text-opacity, 1))}.text-primary{--tw-text-opacity:1;color:rgb(79 70 229 / var(--tw-text-opacity, 1))}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.opacity-50{opacity:0.5}.shadow-md{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow{--tw-shadow:0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.transition{transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-150{transition-duration:150ms}.ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.after\:absolute::after{content:var(--tw-content);position:absolute}.after\:left-\[2px\]::after{content:var(--tw-content);left:2px}.after\:top-\[2px\]::after{content:var(--tw-content);top:2px}.after\:h-5::after{content:var(--tw-content);height:1.25rem}.after\:w-5::after{content:var(--tw-content);width:1.25rem}.after\:rounded-full::after{content:var(--tw-content);border-radius:9999px}.after\:border::after{content:var(--tw-content);border-width:1px}.after\:border-gray-300::after{content:var(--tw-content);--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.after\:bg-white::after{content:var(--tw-content);--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.after\:transition-all::after{content:var(--tw-content);transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.after\:content-\[\'\'\]::after{--tw-content:'';content:var(--tw-content)}.hover\:bg-gray-100:hover{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.hover\:bg-indigo-700:hover{--tw-bg-opacity:1;background-color:rgb(67 56 202 / var(--tw-bg-opacity, 1))}.hover\:bg-orange-600:hover{--tw-bg-opacity:1;background-color:rgb(234 88 12 / var(--tw-bg-opacity, 1))}.hover\:bg-red-50:hover{--tw-bg-opacity:1;background-color:rgb(254 242 242 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-200:hover{--tw-bg-opacity:1;background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-50:hover{--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))}.hover\:text-primary:hover{--tw-text-opacity:1;color:rgb(79 70 229 / var(--tw-text-opacity, 1))}.hover\:text-red-700:hover{--tw-text-opacity:1;color:rgb(185 28 28 / var(--tw-text-opacity, 1))}.focus\:border-primary:focus{--tw-border-opacity:1;border-color:rgb(79 70 229 / var(--tw-border-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-primary:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(79 70 229 / var(--tw-ring-opacity, 1))}.focus\:ring-red-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(239 68 68 / var(--tw-ring-opacity, 1))}.focus\:ring-secondary:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(249 115 22 / var(--tw-ring-opacity, 1))}.focus\:ring-offset-2:focus{--tw-ring-offset-width:2px}.peer:checked ~ .peer-checked\:bg-primary{--tw-bg-opacity:1;background-color:rgb(79 70 229 / var(--tw-bg-opacity, 1))}.peer:checked ~ .peer-checked\:after\:translate-x-full::after{content:var(--tw-content);--tw-translate-x:100%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.peer:checked ~ .peer-checked\:after\:border-white::after{content:var(--tw-content);--tw-border-opacity:1;border-color:rgb(255 255 255 / var(--tw-border-opacity, 1))}.peer:focus ~ .peer-focus\:outline-none{outline:2px solid transparent;outline-offset:2px}.peer:focus ~ .peer-focus\:ring-4{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.peer:focus ~ .peer-focus\:ring-primary\/40{--tw-ring-color:rgb(79 70 229 / 0.4)}@media (min-width: 640px){.sm\:w-auto{width:auto}.sm\:w-20{width:5rem}.sm\:flex-row{flex-direction:row}.sm\:justify-start{justify-content:flex-start}.sm\:space-x-4 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.sm\:space-y-0 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0px * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0px * var(--tw-space-y-reverse))}.sm\:overflow-x-visible{overflow-x:visible}.sm\:p-8{padding:2rem}.sm\:text-4xl{font-size:2.25rem;line-height:2.5rem}}@media (min-width: 768px){.md\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}}@media (min-width: 1024px){.lg\:grid-cols-3{grid-template-columns:repeat(3, minmax(0, 1fr))}}</style></head>

<body class="bg-background min-h-screen p-4 sm:p-8 font-sans">

    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Pace Assigner</h1>
        </header>



        <div class="bg-card shadow-xl rounded-xl p-6 sm:p-8">
            <h2 class="text-2xl font-semibold text-primary mb-4 border-b pb-3">Assignment Results</h2>
            <p id="status" class="success font-bold text-lg mb-4">Status: Done!</p>

            <div id="results-display" class="space-y-4">
                <h3 class="font-semibold text-lg text-gray-800 pb-2">Assignments by Pace Group</h3>
                <div id="groups-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="p-4 bg-white shadow rounded-lg border-l-4 border-primary">
                            <p class="font-bold text-md mb-2">8:00 min/mile <span class="text-gray-500 font-normal">(1 runners)</span></p>
                            <div class="flex flex-wrap"><span class="inline-block bg-primary/20 text-primary px-2 py-0.5 text-xs font-medium rounded-full m-0.5">asdfasdfa (2)</span></div>
                        </div>

                        <div class="p-4 bg-white shadow rounded-lg border-l-4 border-primary">
                            <p class="font-bold text-md mb-2">8:30 min/mile <span class="text-gray-500 font-normal">(1 runners)</span></p>
                            <div class="flex flex-wrap"><span class="inline-block bg-primary/20 text-primary px-2 py-0.5 text-xs font-medium rounded-full m-0.5">asdfasdf (1)</span></div>
                        </div>

                        <div class="p-4 bg-white shadow rounded-lg border-l-4 border-primary">
                            <p class="font-bold text-md mb-2">9:00 min/mile <span class="text-gray-500 font-normal">(1 runners)</span></p>
                            <div class="flex flex-wrap"><span class="inline-block bg-primary/20 text-primary px-2 py-0.5 text-xs font-medium rounded-full m-0.5">asdfasdfasdf (3)</span></div>
                        </div>
                    </div>
            </div>




        </div>
        <br>


        <script>
            // Global Constants and State
            const PACES = [
                '7:00 min/mile', '7:30 min/mile', '8:00 min/mile', '8:30 min/mile', '9:00 min/mile',
                '9:30 min/mile', '10:00 min/mile', '10:30 min/mile', '11:00 min/mile'
            ];
            let R = {}; // Runner data store: { runnerId: { id, name, seniority, paces, active } }
            let result_string = '' // Runner data final
            let rCount = 0; // Counter for fallback ID generation
            let currentView = 'runner'; // 'runner' or 'pace'
            let inputChanged = false; // Flag to check if inputs have changed since last solve
            let hasEverSolved = false; // Flag to track if the solver has ever run successfully
            let editingState = { pace: null, runnerId: null }; // State for adding a new runner in Pace View

            // DOM Element references
            const sEl = document.getElementById('status');
            const resEl = document.getElementById('results-display');
            const solBtn = document.getElementById('solve-button');

            /**
             * Generates a unique runner ID, using crypto.randomUUID if available,
             * otherwise falling back to a counter-based ID.
             * @returns {string} The unique ID.
             */
            function genId() {
                return (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : `r${++rCount}`;
            }

            /**
             * Sets the disabled state of the 'Run Assigner' button.
             * @param {boolean} enable True to enable, false to disable.
             */
            function setBtnState(enable) {
                solBtn.disabled = !enable;
                if (enable) {
                    solBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    solBtn.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }

            /**
             * Marks the application state as changed, enabling the solver button and updating status.
             */
            function markChanged() {
                // Only update if it's the first change or if we were previously solved/ready
                if (!inputChanged || (!hasEverSolved && sEl.textContent !== 'Status: Ready to configure runners and solve.')) {
                    inputChanged = true;
                    setBtnState(true);

                    if (hasEverSolved) {
                        sEl.textContent = 'Status: Input changed. Run solver again.';
                        sEl.className = 'font-bold text-lg mb-4 text-secondary';
                    } else {
                        sEl.textContent = 'Status: Ready to configure runners and solve.';
                        sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                    }
                }
            }

            /**
             * Finds all active runners that have duplicate names (case-insensitive, trimmed).
             * @returns {Set<string>} A set of runner IDs that have duplicate names.
             */
            function findDups() {
                const activeRunners = Object.values(R).filter(r => r.active && r.name.trim());
                const namesCount = {};
                activeRunners.forEach(r => {
                    const normalizedName = r.name.trim().toLowerCase();
                    namesCount[normalizedName] = namesCount[normalizedName] || [];
                    namesCount[normalizedName].push(r.id);
                });

                const duplicateIds = new Set();
                for (const name in namesCount) {
                    if (namesCount[name].length > 1) {
                        namesCount[name].forEach(id => duplicateIds.add(id));
                    }
                }
                return duplicateIds;
            }

            /**
             * Creates a new runner object in the global data store R.
             * @param {string} name Runner's name.
             * @param {number|null} seniority Runner's seniority.
             * @param {string[]} paces Array of preferred paces.
             * @param {boolean} active Active status.
             * @returns {string} The new runner's ID.
             */
            function createNewRunnerInData(name = '', seniority = null, paces = [], active = true) {
                const id = genId();
                R[id] = {
                    id: id,
                    name: name,
                    seniority: seniority !== null ? seniority : Object.keys(R).length + 1,
                    paces: paces,
                    active: active
                };
                markChanged();
                return id;
            }

            /**
             * Adds a new runner row to the view.
             * @param {boolean} shouldRender If true, re-renders the current view and scrolls to the new runner.
             */
            function addRunner(shouldRender = true) {
                const id = createNewRunnerInData();
                if (shouldRender) {
                    if (currentView === 'runner') {
                        renderRView();
                        const newRow = document.getElementById(`runner-row-${id}`);
                        if (newRow) newRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    } else {
                        renderPView();
                    }
                }
            }

            /**
             * Updates a specific field for a runner in the data store.
             * @param {string} id Runner ID.
             * @param {string} field Field to update ('name', 'seniority', 'active', 'paces').
             * @param {*} value The new value.
             */
            function updateRunnerData(id, field, value) {
                if (R[id]) {
                    // Basic validation for seniority
                    if (field === 'seniority' && isNaN(value)) return;
                    R[id][field] = value;
                    markChanged();
                }
            }

            /**
             * Deletes a runner from the data store and re-renders the current view.
             * @param {string} runnerId The ID of the runner to delete.
             */
            function deleteRunner(runnerId) {
                if (R[runnerId]) {
                    delete R[runnerId];
                    if (currentView === 'runner') {
                        renderRView();
                    } else {
                        // Clear editing state if the deleted runner was being edited in pace view
                        if (editingState.runnerId === runnerId) {
                            editingState = { pace: null, runnerId: null };
                        }
                        renderPView();
                    }
                    markChanged();
                }
            }

            /**
             * Clears all runner data and resets state.
             * @param {boolean} skipNewRow If true, doesn't add the default initial row.
             */
            function clearAllRunners(skipNewRow = false) {
                R = {};
                editingState = { pace: null, runnerId: null };
                rCount = 0;
                inputChanged = true;
                hasEverSolved = false;
                resEl.innerHTML = '';

                if (!skipNewRow) {
                    addRunner(false); // Add a blank one for convenience, but don't force render
                }

                if (currentView === 'runner') {
                    renderRView();
                } else {
                    renderPView();
                }

                sEl.textContent = 'Status: All runners cleared. A new row has been added.';
                sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                setBtnState(true);
            }

            // --- Pace View Functions ---

            /**
             * Removes a pace preference from a runner. Deletes the runner if no paces remain.
             * @param {string} rId Runner ID.
             * @param {string} paceToRemove Pace string to remove.
             */
            function removePaceFromRunner(rId, paceToRemove) {
                if (!R[rId]) return;
                const runner = R[rId];
                const initialPaceCount = runner.paces.length;

                runner.paces = runner.paces.filter(p => p !== paceToRemove);

                if (runner.paces.length === 0) {
                    // Delete runner if they have no paces left
                    const deletedName = runner.name || 'Untitled Runner';
                    delete R[rId];
                    sEl.textContent = `Status: Runner '${deletedName}' deleted because they had no remaining pace preferences.`;
                    sEl.className = 'success font-bold text-lg mb-4';
                } else if (runner.paces.length < initialPaceCount) {
                    sEl.textContent = `Status: Removed ${paceToRemove} preference from ${runner.name || 'Untitled Runner'}.`;
                    sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                } else {
                    return; // Nothing changed
                }

                markChanged();
                renderPView();
                setTimeout(() => markChanged(), 3000); // Re-flag as changed after status update
            }

            /**
             * Starts the process of adding a new runner in the Pace View.
             * @param {string} pace The pace to pre-assign to the new runner.
             */
            function startAddingRunner(pace) {
                // If we were editing another new runner, delete them before starting a new one
                if (editingState.runnerId) {
                    delete R[editingState.runnerId];
                }

                // Create a temporary, unnamed runner object
                const newRunnerId = createNewRunnerInData('', null, [pace], true);
                editingState = { pace: pace, runnerId: newRunnerId };
                renderPView();

                // Focus the input field
                const inputEl = document.getElementById(`new-runner-input-${newRunnerId}`);
                if (inputEl) setTimeout(() => inputEl.focus(), 0);
            }

            /**
             * Finalizes the new runner creation in Pace View (called on Enter or Blur).
             * @param {string} pace The pace being assigned.
             * @param {string} runnerId The ID of the temporary runner object.
             * @param {string} name The entered runner name.
             */
            function finalizeNewRunnerName(pace, runnerId, name) {
                if (editingState.runnerId !== runnerId) return;

                name = name.trim();

                if (!name) {
                    // Name is blank, cancel creation
                    delete R[runnerId];
                    editingState = { pace: null, runnerId: null };
                    renderPView();
                    sEl.textContent = "Error: Runner creation cancelled. Name cannot be blank.";
                    sEl.className = 'error font-bold text-lg mb-4';
                    setTimeout(() => markChanged(), 2000);
                    return;
                }

                const normalizedName = name.toLowerCase();
                let existingRunnerId = null;

                // Check if runner with this name already exists
                for (const id in R) {
                    if (id !== runnerId && R[id].name.toLowerCase() === normalizedName) {
                        existingRunnerId = id;
                        break;
                    }
                }

                if (existingRunnerId) {
                    // Found existing runner: assign pace to them and delete the temporary one
                    const existingRunner = R[existingRunnerId];
                    if (!existingRunner.paces.includes(pace)) {
                        existingRunner.paces.push(pace);
                        sEl.textContent = `Status: Pace preference added to existing runner '${existingRunner.name}'!`;
                        sEl.className = 'success font-bold text-lg mb-4';
                    } else {
                        sEl.textContent = `Status: Runner '${existingRunner.name}' already prefers ${pace}.`;
                        sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                    }
                    delete R[runnerId];
                } else {
                    // New runner: finalize name and set seniority
                    R[runnerId].name = name;
                    if (R[runnerId].seniority === null) {
                        R[runnerId].seniority = Object.keys(R).length;
                    }
                    sEl.textContent = `Status: New runner '${name}' created and assigned to ${pace}.`;
                    sEl.className = 'success font-bold text-lg mb-4';
                }

                // Reset editing state and re-render
                editingState = { pace: null, runnerId: null };
                renderPView();
                markChanged();
                setTimeout(() => markChanged(), 3000); // Re-flag as changed after status update
            }

            /**
             * Handles the keydown event on the new runner name input in Pace View.
             * @param {Event} e Keydown event.
             * @param {string} pace Pace string.
             * @param {string} rId Runner ID.
             */
            function handleNewRunnerNameInput(e, pace, rId) {
                if (e.key !== 'Enter') return;
                e.preventDefault();
                const name = e.target.value;
                finalizeNewRunnerName(pace, rId, name);
            }

            /**
             * Handles the blur event on the new runner name input in Pace View.
             * @param {string} pace Pace string.
             * @param {string} rId Runner ID.
             */
            function handleNewRunnerNameBlur(pace, rId) {
                if (editingState.runnerId !== rId) return;
                const inputEl = document.getElementById(`new-runner-input-${rId}`);
                if (!inputEl) return;
                const name = inputEl.value;
                finalizeNewRunnerName(pace, rId, name);
            }

            /**
             * Renders the Pace View (paces-list).
             */
            function renderPView() {
                const pacesListEl = document.getElementById('paces-list');
                pacesListEl.innerHTML = '';
                const allRunners = Object.values(R);

                PACES.forEach(pace => {
                    // Filter runners for this pace, excluding the temp runner if currently editing
                    const runnersInPace = allRunners.filter(r => r.paces.includes(pace) && r.id !== editingState.runnerId);
                    const sortedRunners = runnersInPace.sort((a, b) => a.seniority - b.seniority);

                    const runnersHtml = sortedRunners.map(r => {
                        if (!r.active) return '';
                        return `<span class="inline-flex items-center bg-primary/20 text-primary px-2 py-0.5 text-xs font-medium rounded-full m-0.5 whitespace-nowrap">
                        <span>${r.name || 'Untitled Runner'} (${r.seniority})</span>
                        <button onclick="removePaceFromRunner('${r.id}', '${pace}')" title="Remove ${pace} preference from ${r.name}" class="ml-1 text-primary/70 hover:text-red-600 transition duration-150 p-0.5 rounded-full hover:bg-white/50 leading-none focus:outline-none focus:ring-2 focus:ring-primary/50">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                        </button>
                    </span>`;
                    }).join('');

                    const isEditingThisPace = editingState.pace === pace;
                    const editingRunner = isEditingThisPace ? R[editingState.runnerId] : null;

                    pacesListEl.innerHTML += `
                    <div class="p-4 bg-white shadow rounded-lg border-l-4 border-secondary flex flex-col justify-between items-start">
                        <div class="w-full flex justify-between items-start sm:items-center flex-col sm:flex-row mb-3">
                            <p class="font-bold text-lg mb-2 sm:mb-0">${pace} <span class="text-gray-500 font-normal text-sm">(${runnersInPace.filter(r => r.active).length} active runners)</span></p>
                            ${!isEditingThisPace ? `
                                <button onclick="startAddingRunner('${pace}')" class="px-4 py-2 border border-transparent text-xs font-medium rounded-lg shadow-sm text-white bg-secondary hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-secondary transition duration-150 ease-in-out whitespace-nowrap">
                                    Add New Runner to this Pace
                                </button>` : ''}
                        </div>
                        <div class="flex flex-wrap min-h-[2rem] w-full">
                            ${runnersHtml.length > 0 ? runnersHtml : '<span class="mt-1 text-gray-400 text-sm">No runners currently prefer this pace.</span>'}
                            ${isEditingThisPace && editingRunner ? `
                                <input type="text" id="new-runner-input-${editingRunner.id}" placeholder="Enter runner name and press Enter or blur"
                                    onkeydown="handleNewRunnerNameInput(event, '${pace}', '${editingRunner.id}')"
                                    onblur="handleNewRunnerNameBlur('${pace}', '${editingRunner.id}')"
                                    class="w-full sm:w-80 p-2 border border-primary rounded-lg text-sm focus:ring-primary focus:border-primary shadow-md">
                            ` : ''}
                        </div>
                    </div>
                `;
                });

                // Re-focus the input field after rendering if in editing state
                if (editingState.runnerId) {
                    const inputEl = document.getElementById(`new-runner-input-${editingState.runnerId}`);
                    if (inputEl) setTimeout(() => inputEl.focus(), 0);
                }
            }

            // --- View Switching ---

            /**
             * Switches the configuration view between 'runner' and 'pace'.
             * @param {string} viewName 'runner' or 'pace'.
             */
            function switchView(viewName) {
                // Before switching away from the current view, sync data or clean up temp state
                if (currentView === 'runner') {
                    syncData();
                } else if (currentView === 'pace') {
                    // Clean up temporary runner if one was being added
                    if (editingState.runnerId) {
                        delete R[editingState.runnerId];
                        editingState = { pace: null, runnerId: null };
                    }
                }

                currentView = viewName;
                const runnerViewContainer = document.getElementById('runner-view-container');
                const paceViewContainer = document.getElementById('pace-view-container');
                const runnerViewTab = document.getElementById('view-runner-tab');
                const paceViewTab = document.getElementById('view-pace-tab');

                if (viewName === 'runner') {
                    runnerViewContainer.classList.remove('hidden');
                    paceViewContainer.classList.add('hidden');
                    renderRView();
                    runnerViewTab.classList.remove('tab-inactive');
                    runnerViewTab.classList.add('bg-primary', 'text-white');
                    paceViewTab.classList.remove('bg-primary', 'text-white');
                    paceViewTab.classList.add('tab-inactive');
                } else if (viewName === 'pace') {
                    runnerViewContainer.classList.add('hidden');
                    paceViewContainer.classList.remove('hidden');
                    renderPView();
                    paceViewTab.classList.remove('tab-inactive');
                    paceViewTab.classList.add('bg-primary', 'text-white');
                    runnerViewTab.classList.remove('bg-primary', 'text-white');
                    runnerViewTab.classList.add('tab-inactive');
                }
            }

            // --- Runner View Functions ---

            /**
             * Helper to get relevant DOM elements for a runner row.
             * @param {string} rId Runner ID.
             * @returns {object|null} Object containing input elements, or null if not found.
             */
            function getRunnerElements(rId) {
                const row = document.getElementById(`runner-row-${rId}`);
                if (!row) return null;
                return {
                    nameInput: row.querySelector('.runner-name'),
                    paceContainer: row.querySelector('.pace-container'),
                };
            }

            /**
             * Validates a single runner row's inputs and applies error styling.
             * @param {string} rId Runner ID.
             * @param {Set<string>} duplicateIds Set of runner IDs that have duplicate names.
             */
            function validateRow(rId, duplicateIds) {
                const runner = R[rId];
                const elements = getRunnerElements(rId);
                if (!elements || !runner) return;

                const { nameInput, paceContainer } = elements;

                // Reset validation styles
                nameInput.classList.remove('validation-border');
                paceContainer.classList.remove('validation-border');

                // Only validate active runners
                if (!runner.active) return;

                // 1. Check for duplicates
                if (duplicateIds.has(rId)) {
                    nameInput.classList.add('validation-border');
                    return;
                }

                // 2. Check for missing name
                if (!runner.name.trim()) {
                    nameInput.classList.add('validation-border');
                    return;
                }

                // 3. Check for missing pace preference
                if (runner.paces.length === 0) {
                    paceContainer.classList.add('validation-border');
                }
            }

            /**
             * Generates the HTML for pace selection checkboxes for a runner.
             * @param {string} rId Runner ID.
             * @param {string[]} currentPaces Array of paces currently preferred.
             * @returns {string} HTML string for pace checkboxes.
             */
            function generatePaceCheckboxes(rId, currentPaces) {
                return PACES.map(pace => `
                <input type="checkbox" id="pace-${rId}-${pace.replace(/[:\/ ]/g, '-')}" data-pace="${pace}"
                    class="pace-checkbox hidden" value="${pace}" data-runner-id="${rId}"
                    ${currentPaces.includes(pace) ? 'checked' : ''}>
                <label for="pace-${rId}-${pace.replace(/[:\/ ]/g, '-')}"
                    class="inline-block px-2 py-1 text-xs font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-full cursor-pointer
                    hover:bg-gray-200 transition duration-150 ease-in-out m-0.5 whitespace-nowrap">
                    ${pace.split(' ')[0]}
                </label>
            `).join('');
            }

            /**
             * Creates and returns a single runner table row element.
             * @param {object} runner The runner data object.
             * @param {number} index The index of the runner in the list (for # column).
             * @returns {HTMLElement} The created table row.
             */
            function renderRRow(runner, index) {
                const row = document.createElement('tr');
                row.id = `runner-row-${runner.id}`;
                row.className = 'runner-row hover:bg-gray-50 transition duration-150 relative'; // Added relative for mobile delete button
                row.innerHTML = `
                <td class="px-3 py-3 whitespace-nowrap">
                    <span class="text-sm text-gray-500">${index + 1}</span>
                </td>
                <td class="px-6 py-3">
                    <input type="text" placeholder="Runner Name" required value="${runner.name}" data-runner-id="${runner.id}"
                        class="runner-name w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-primary focus:border-primary">
                </td>
                <td class="px-6 py-3 whitespace-nowrap">
                    <input type="number" value="${runner.seniority}" min="1" required data-runner-id="${runner.id}"
                        class="runner-seniority w-full sm:w-20 p-2 border border-gray-300 rounded-lg text-sm text-center focus:ring-primary focus:border-primary">
                </td>
                <td class="px-6 py-3">
                    <div id="pace-container-${runner.id}" class="pace-container flex flex-wrap space-x-1 p-1 border border-transparent rounded-lg transition duration-150 ease-in-out">
                        ${generatePaceCheckboxes(runner.id, runner.paces)}
                    </div>
                </td>
                <td class="px-3 py-3 whitespace-nowrap">
                    <div class="flex justify-center sm:justify-start items-center h-full">
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" ${runner.active ? 'checked' : ''} class="sr-only peer runner-active-toggle" data-runner-id="${runner.id}">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary/40 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                            <span class="ml-3 text-sm font-medium text-gray-900 sr-only">Active Toggle</span>
                        </label>
                    </div>
                </td>
                <td class="px-3 py-3 whitespace-nowrap">
                    <button onclick="deleteRunner('${runner.id}')" class="p-2 text-red-500 hover:text-red-700 rounded-full transition duration-150">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </td>
            `;
                return row;
            }

            /**
             * Renders the Runner View (runners-list table body).
             */
            function renderRView() {
                const tableBody = document.getElementById('runners-list');
                tableBody.innerHTML = '';
                const sortedRunners = Object.values(R).sort((a, b) => a.seniority - b.seniority);
                const duplicateIds = findDups();

                sortedRunners.forEach((runner, index) => {
                    const newRow = renderRRow(runner, index);
                    tableBody.appendChild(newRow);
                    validateRow(runner.id, duplicateIds);
                });

                setupRListeners();
            }

            /**
             * Sets up the event listeners on the runners list for input/change events.
             */
            function setupRListeners() {
                const runnersListEl = document.getElementById('runners-list');
                // Remove previous listeners to prevent duplicates
                runnersListEl.removeEventListener('change', handleRInput);
                runnersListEl.removeEventListener('input', handleRInput);

                // Add new listeners
                runnersListEl.addEventListener('change', handleRInput); // for checkboxes and toggles
                runnersListEl.addEventListener('input', handleRInput); // for text and number inputs
            }

            /**
             * Handles input and change events in the Runner View, updating the data store and running validation.
             * @param {Event} e The event object.
             */
            function handleRInput(e) {
                const target = e.target;
                const rId = target.dataset.runnerId;

                if (!R[rId]) return;

                // Update data based on the input type
                if (target.classList.contains('runner-name')) {
                    updateRunnerData(rId, 'name', target.value.trim());
                } else if (target.classList.contains('runner-seniority')) {
                    updateRunnerData(rId, 'seniority', parseInt(target.value));
                } else if (target.classList.contains('runner-active-toggle')) {
                    updateRunnerData(rId, 'active', target.checked);
                } else if (target.classList.contains('pace-checkbox')) {
                    const runner = R[rId];
                    const currentPaces = runner.paces;
                    const paceValue = target.getAttribute('data-pace');

                    if (target.checked) {
                        if (!currentPaces.includes(paceValue)) {
                            currentPaces.push(paceValue);
                        }
                    } else {
                        const index = currentPaces.indexOf(paceValue);
                        if (index > -1) {
                            currentPaces.splice(index, 1);
                        }
                    }
                    runner.paces = currentPaces;
                }

                const duplicateIds = findDups();

                // Re-validate all rows when names or active status changes (as it affects duplicates/active status)
                if (target.classList.contains('runner-name') || target.classList.contains('runner-active-toggle')) {
                    Object.keys(R).forEach(id => {
                        validateRow(id, duplicateIds);
                    });
                } else {
                    // Otherwise, just validate the current row
                    validateRow(rId, duplicateIds);
                }

                markChanged();
            }

            /**
             * Synchronizes the DOM state (inputs) back to the global R data store.
             * This is crucial before solving or switching from Runner View.
             */
            function syncData() {
                if (currentView === 'pace') return; // Only sync if we are in Runner View

                const rows = document.querySelectorAll('.runner-row');
                const duplicateIds = findDups();

                rows.forEach(row => {
                    const rId = row.id.replace('runner-row-', '');
                    if (!R[rId]) return;

                    const nameInput = row.querySelector('.runner-name');
                    const seniorityInput = row.querySelector('.runner-seniority');
                    const activeToggle = row.querySelector('.runner-active-toggle');
                    const paceCheckboxes = row.querySelectorAll('.pace-checkbox');

                    const selectedPaces = Array.from(paceCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.getAttribute('data-pace'));

                    R[rId].name = nameInput.value.trim();
                    R[rId].seniority = parseInt(seniorityInput.value) || 1;
                    R[rId].paces = selectedPaces;
                    R[rId].active = activeToggle.checked;

                    validateRow(rId, duplicateIds);
                });
            }

            // --- Import/Export Functions ---

            /**
             * Exports the runner data as a JSON string, copying it to the clipboard.
             */
            function exportRunners() {
                syncData(); // Ensure R is up-to-date
                const runnerData = Object.values(R)
                    .filter(r => r.name) // Don't export unnamed runners
                    .map(r => ({
                        name: r.name,
                        seniority: r.seniority,
                        paces: r.paces,
                        active: r.active
                    }));

                const jsonString = JSON.stringify(runnerData, null, 2);

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(jsonString).then(() => {
                        sEl.textContent = 'Status: Runner data copied to clipboard as JSON!';
                        sEl.className = 'success font-bold text-lg mb-4';
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        // Fallback for browsers without clipboard access
                        prompt("Copy the following JSON data manually:", jsonString);
                        sEl.textContent = 'Status: Clipboard copy failed. Data ready in prompt box for manual copy.';
                        sEl.className = 'font-bold text-lg mb-4 text-secondary';
                    });
                } else {
                    // Fallback for browsers without clipboard support
                    prompt("Copy the following JSON data manually:", jsonString);
                    sEl.textContent = 'Status: Runner data ready in prompt box for manual copy.';
                    sEl.className = 'font-bold text-lg mb-4 text-secondary';
                }
            }

            function exportAssignments() {
                syncData(); // Ensure R is up-to-date
                // const runnerData = Object.values(R)
                //     .filter(r => r.name) // Don't export unnamed runners
                //     .map(r => ({
                //         name: r.name,
                //         seniority: r.seniority,
                //         paces: r.paces,
                //         active: r.active
                //     }));

                const jsonString = result_string

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(jsonString).then(() => {
                        sEl.textContent = 'Status: Runner assignments copied to clipboard!';
                        sEl.className = 'success font-bold text-lg mb-4';
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        // Fallback for browsers without clipboard access
                        prompt("Copy the following JSON data manually:", jsonString);
                        sEl.textContent = 'Status: Clipboard copy failed. Data ready in prompt box for manual copy.';
                        sEl.className = 'font-bold text-lg mb-4 text-secondary';
                    });
                } else {
                    // Fallback for browsers without clipboard support
                    prompt("Copy the following JSON data manually:", jsonString);
                    sEl.textContent = 'Status: Runner assignments ready in prompt box for manual copy.';
                    sEl.className = 'font-bold text-lg mb-4 text-secondary';
                }
            }

            /**
             * Imports runner data from a JSON string provided by the user.
             */
            function importRunners() {
                const importString = prompt("Paste the JSON string containing runner data here:");

                if (!importString) {
                    sEl.textContent = 'Status: Import cancelled.';
                    sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                    return;
                }

                try {
                    const importedRunners = JSON.parse(importString);

                    // Basic validation of the imported structure
                    if (!Array.isArray(importedRunners) || importedRunners.some(r => typeof r !== 'object' || r.name === undefined || r.seniority === undefined)) {
                        throw new Error("Invalid JSON structure. Expected an array of runner objects with 'name' and 'seniority' fields.");
                    }

                    clearAllRunners(true); // Clear data but skip adding a new default row

                    importedRunners.forEach(runner => {
                        createNewRunnerInData(
                            runner.name,
                            runner.seniority,
                            runner.paces || [],
                            runner.active !== undefined ? runner.active : true
                        );
                    });

                    if (currentView === 'runner') {
                        renderRView();
                    } else {
                        renderPView();
                    }

                    markChanged();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    sEl.textContent = `Status: Successfully imported ${importedRunners.length} runners. Run the solver to get assignments.`;
                    sEl.className = 'success font-bold text-lg mb-4';

                } catch (e) {
                    console.error('Import Error:', e);
                    sEl.textContent = `Error: Failed to import data. ${e.message || 'Invalid JSON format.'}`;
                    sEl.className = 'error font-bold text-lg mb-4';
                }
            }

            // --- Optimization Solver Functions ---

            /**
             * Generates the list of available pace groups (PACES) and their cost values (pace in minutes).
             * @returns {object} Map of pace string to minutes/mile float.
             */
            function generatePaceGroups() {
                const paces = {};
                // Paces from 7:00 (14 half-minutes) to 11:00 (22 half-minutes)
                for (let halfMinute = 14; halfMinute <= 22; halfMinute++) {
                    const paceMinutes = halfMinute / 2.0;
                    const minutes = Math.floor(paceMinutes);
                    const seconds = Math.round((paceMinutes - minutes) * 60);
                    const paceStr = `${minutes}:${seconds.toString().padStart(2, '0')} min/mile`;
                    paces[paceStr] = paceMinutes;
                }
                return paces;
            }

            /**
             * Solves the assignment problem using the javascript-lp-solver library.
             * This is a two-phase optimization problem:
             * 1. Minimize the range (max group size - min group size).
             * 2. Minimize total pace cost (prioritizing faster, preferred paces) while keeping the optimal range from Phase 1.
             * @param {object} runnerInputData Filtered data of active, valid runners.
             * @returns {object} The final assignments object or an error message.
             */
            function solveAssignmentProblem(runnerInputData) {
                const paceGroups = generatePaceGroups();
                const G = Object.keys(paceGroups); // Pace Groups (Goals)
                const PACE_COSTS = { ...paceGroups }; // Pace time in minutes
                const MAX_PACE_COST = Math.max(...Object.values(PACE_COSTS));

                const R_unsorted = Object.keys(runnerInputData); // Runner IDs (Individuals)
                if (R_unsorted.length === 0) return { error: "No active runners provided for assignment." };

                // Prepare preferences and ranks
                const runnerPreferences = {};
                const seniorityRanks = {};
                R_unsorted.forEach(rId => {
                    runnerPreferences[rId] = runnerInputData[rId].paces;
                    seniorityRanks[rId] = runnerInputData[rId].seniority;
                });

                // Sort runners by seniority (for deterministic assignment priority)
                const R = R_unsorted.sort((a, b) => {
                    const rankDiff = seniorityRanks[a] - seniorityRanks[b];
                    // If ranks are equal, sort by ID to ensure consistency
                    return rankDiff !== 0 ? rankDiff : a.localeCompare(b);
                });

                // --- Optimization Model Setup ---

                // Constants for tie-breaking and objective function
                const epsilon = 0.000001; // Small value for reward weighting
                const MAX_RANK = Math.max(...Object.values(seniorityRanks));

                // Seniority Reward Factor: Higher for lower seniority number (e.g., Seniority 1 gets MAX_RANK)
                const SENIORITY_REWARD_FACTOR = Object.fromEntries(R.map(r => [r, MAX_RANK + 1 - seniorityRanks[r]]));

                // Pace Speed/Distance: Higher for faster (lower pace cost)
                const PACE_SPEED_DISTANCE = Object.fromEntries(G.map(g => [g, MAX_PACE_COST - PACE_COSTS[g]]));

                // Calculate the total seniority/pace reward for each potential assignment (r -> g)
                const PACE_SENIORITY_REWARD = {};
                for (const r of R) {
                    for (const g of G) {
                        const isPreferred = runnerPreferences[r].includes(g);
                        // Only reward for preferred paces. Reward is based on seniority AND pace speed.
                        PACE_SENIORITY_REWARD[`${r}|${g}`] = isPreferred
                            ? (SENIORITY_REWARD_FACTOR[r] * PACE_SPEED_DISTANCE[g] * epsilon)
                            : 0;
                    }
                }

                // Ability Constraint: 1 if the runner prefers the pace, 0 otherwise
                const ability = {};
                for (const r of R) {
                    for (const g of G) {
                        ability[`${r}|${g}`] = runnerPreferences[r].includes(g) ? 1 : 0;
                    }
                }

                // --- Phase 1: Minimize Group Size Range (Max - Min) ---

                let model1 = {
                    optimize: "range", // Minimize Z_max - Z_min
                    opType: "min",
                    constraints: {},
                    variables: {},
                    ints: {} // Integer constraints for assignments and counts
                };

                // Range Variables: range is Z_max - Z_min. We want to minimize this.
                model1.variables["Z_max"] = { range: 1 };
                model1.variables["Z_min"] = { range: -1 };

                // Group Size Constraints (N_g >= Z_min and N_g <= Z_max)
                G.forEach(g => {
                    const countVar = `N_${g}`;
                    model1.variables[countVar] = {
                        [`count_link_${g}`]: 1, // links to the count constraint
                        [`max_bound_${g}`]: -1, // links to Z_max
                        [`min_bound_${g}`]: -1 // links to Z_min
                    };
                    model1.ints[countVar] = 1; // Group count must be integer

                    // N_g - sum(assignments) = 0
                    model1.constraints[`count_link_${g}`] = { equal: 0 };

                    // N_g - Z_max <= 0  =>  N_g <= Z_max
                    model1.constraints[`max_bound_${g}`] = { min: 0 }; // min: 0 means N_g - Z_max >= 0 or - (N_g - Z_max) <= 0
                    model1.variables["Z_max"][`max_bound_${g}`] = 1;

                    // -N_g + Z_min <= 0 => Z_min <= N_g
                    model1.constraints[`min_bound_${g}`] = { max: 0 }; // max: 0 means -N_g + Z_min <= 0
                    model1.variables["Z_min"][`min_bound_${g}`] = 1;
                });

                // Runner Assignment Constraints (Each runner assigned exactly once)
                R.forEach(r => {
                    const runnerConstraint = `runner_assign_${r}`;
                    model1.constraints[runnerConstraint] = { equal: 1 };

                    G.forEach(g => {
                        const assignVar = `assign_${r}_${g}`;
                        model1.variables[assignVar] = {
                            [runnerConstraint]: 1, // Sum of assignments for runner r must equal 1
                            [`count_link_${g}`]: -1 // Subtracts 1 from the group count N_g
                        };
                        model1.ints[assignVar] = 1; // Assignment must be integer (0 or 1)

                        // Ability Constraint: Must only assign if the runner prefers the pace
                        const abilityConstraint = `ability_${r}_${g}`;
                        model1.constraints[abilityConstraint] = { min: 0, max: ability[`${r}|${g}`] };
                        model1.variables[assignVar][abilityConstraint] = 1;
                    });
                });

                let results1 = solver.Solve(model1);

                if (!results1.feasible) {
                    return { error: "No feasible solution found. Cannot assign all runners based on preferences." };
                }

                const optimalRange = results1.result;

                // --- Phase 2: Minimize Total Pace Cost + Maximize Seniority/Preference Reward ---

                let model2 = {
                    optimize: "totalCost",
                    opType: "min",
                    constraints: {},
                    variables: {},
                    ints: {}
                };

                // Constraint: The range must be fixed to the optimal range from Phase 1
                model2.variables["Z_max_2"] = { fixed_range: 1 };
                model2.variables["Z_min_2"] = { fixed_range: -1 };

                // Group size constraints (re-added for integrity, linked to Phase 2 variables)
                G.forEach(g => {
                    const countVar = `N2_${g}`;
                    model2.variables[countVar] = {
                        [`count_link_2_${g}`]: 1,
                        [`max_bound_2_${g}`]: -1,
                        [`min_bound_2_${g}`]: -1
                    };
                    model2.ints[countVar] = 1;

                    model2.constraints[`count_link_2_${g}`] = { equal: 0 };

                    // N_g - Z_max <= 0  =>  N_g <= Z_max
                    model2.constraints[`max_bound_2_${g}`] = { min: 0 };
                    model2.variables["Z_max_2"][`max_bound_2_${g}`] = 1;

                    // -N_g + Z_min <= 0 => Z_min <= N_g
                    model2.constraints[`min_bound_2_${g}`] = { max: 0 };
                    model2.variables["Z_min_2"][`min_bound_2_${g}`] = 1;
                });

                // Runner Assignment Constraints (Each runner assigned exactly once)
                R.forEach(r => {
                    const runnerConstraint = `runner_assign_2_${r}`;
                    model2.constraints[runnerConstraint] = { equal: 1 };

                    G.forEach(g => {
                        const assignVar = `assign_${r}_${g}`;

                        // Cost calculation: Pace Cost - Seniority/Preference Reward (Minimizing Cost maximizes the Reward)
                        const cost = PACE_COSTS[g] - PACE_SENIORITY_REWARD[`${r}|${g}`];

                        model2.variables[assignVar] = {
                            totalCost: cost, // Objective function coefficient
                            [runnerConstraint]: 1,
                            [`count_link_2_${g}`]: -1
                        };
                        model2.ints[assignVar] = 1;

                        // Ability Constraint: Must only assign if the runner prefers the pace
                        const abilityConstraint = `ability_2_${r}_${g}`;
                        model2.constraints[abilityConstraint] = { min: 0, max: ability[`${r}|${g}`] };
                        model2.variables[assignVar][abilityConstraint] = 1;
                    });
                });

                // Fix the range constraint from Phase 1
                model2.constraints["fixed_range"] = { equal: optimalRange };

                let results2 = solver.Solve(model2);

                if (!results2.feasible) {
                    return { error: "Failed to find a pace-optimal solution that maintains the minimum group balance. Try reducing constraints." };
                }

                // --- Process Final Results ---

                const finalAssignments = {
                    assignments: {}, // { runnerId: paceString }
                    groups: {} // { paceString: [runnerId, ...] }
                };
                G.forEach(g => finalAssignments.groups[g] = []);

                for (const rId in runnerInputData) {
                    for (const g of G) {
                        // Check if the variable for this assignment is 1 (assigned)
                        if (results2[`assign_${rId}_${g}`] === 1) {
                            finalAssignments.assignments[rId] = g;
                            finalAssignments.groups[g].push(rId);
                        }
                    }
                    // Clean up the pace array in the input data (passed by reference)
                    delete runnerInputData[rId].paces;
                }

                finalAssignments.meta = {
                    minRange: optimalRange,
                    totalCost: results2.result
                };

                return finalAssignments;
            }

            /**
             * Main function to run the optimization solver.
             */
            function runSolver() {
                // 1. Ensure all current inputs in Runner View are synced to the data store
                syncData();

                // Check if input has changed since the last solve
                if (!inputChanged && hasEverSolved) {
                    sEl.textContent = 'Status: Input has not changed since last successful solve.';
                    sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                    return;
                }

                resEl.innerHTML = '';
                sEl.textContent = 'Status: Validating runner data...';
                sEl.className = 'font-bold text-lg mb-4 text-gray-800';

                const activeRunnerData = {};
                let blankNameFound = false;
                let missingPacesFound = false;
                const duplicateIds = findDups();
                let duplicateFound = duplicateIds.size > 0;

                // Filter and validate runners
                Object.values(R).forEach(runner => {
                    validateRow(runner.id, duplicateIds); // Apply validation styling
                    if (!runner.active) return; // Skip inactive runners

                    const name = runner.name;
                    if (!name.trim()) {
                        blankNameFound = true;
                    }
                    if (name.trim() && runner.paces.length === 0) {
                        missingPacesFound = true;
                    }

                    // Only add valid, active runners for solving
                    if (name.trim() && runner.paces.length > 0 && !duplicateIds.has(runner.id)) {
                        activeRunnerData[runner.id] = runner;
                    }
                });

                // Handle validation errors
                if (blankNameFound || duplicateFound || missingPacesFound) {
                    let errorMessages = [];
                    if (blankNameFound) errorMessages.push("One or more active runners are missing a **Name**.");
                    if (duplicateFound) errorMessages.push("One or more active runners have **Duplicate Names**.");
                    if (missingPacesFound) errorMessages.push("One or more active runners have **No Pace Preferences** selected.");

                    sEl.textContent = `Error: Data validation failed. ${errorMessages.join(' ')}`;
                    sEl.className = 'error font-bold text-lg mb-4';

                    // Ensure user is on the view where they can see the errors
                    if (currentView === 'pace') switchView('runner');
                    setBtnState(true);
                    return;
                }

                if (Object.keys(activeRunnerData).length === 0) {
                    sEl.textContent = "Status: No active or valid runner data provided.";
                    sEl.className = 'font-bold text-lg mb-4 text-gray-800';
                    setBtnState(false);
                    return;
                }

                // Run the solver
                const assignments = solveAssignmentProblem(activeRunnerData);

                if (assignments.error) {
                    // Handle solver errors (infeasible solution)
                    sEl.textContent = `Error: ${assignments.error}`;
                    sEl.className = 'error font-bold text-lg mb-4';
                    resEl.innerHTML = `<p class="text-red-600 p-3 bg-red-50 rounded-lg">Optimization failed. Check if all active runners have at least one pace preference selected and if the preferences allow for a balanced solution.</p>`;
                    setBtnState(true);
                } else {
                    // Successful solve
                    sEl.textContent = 'Status: Done!';
                    sEl.className = 'success font-bold text-lg mb-4';
                    displayResults(assignments, activeRunnerData);
                    inputChanged = false;
                    hasEverSolved = true;
                    setBtnState(false);
                }
            }

            /**
             * Renders the final assignment results to the results-display area.
             * @param {object} assignments The final assignment object from the solver.
             * @param {object} runnerInputData The active runner data used by the solver.
             */
            function displayResults(assignments, runnerInputData) {
                result_string = ''
                resEl.innerHTML = `
                <h3 class="font-semibold text-lg text-gray-800 pb-2">Assignments by Pace Group</h3>
                <div id="groups-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            `;

                const groupsListEl = document.getElementById('groups-list');

                // Sort paces from fastest to slowest for display
                const sortedPaces = Object.keys(assignments.groups).sort((a, b) => {
                    const paceToMinutes = (paceStr) => {
                        const [minutes, seconds] = paceStr.split(' ')[0].split(':').map(Number);
                        return minutes + seconds / 60;
                    };
                    return paceToMinutes(a) - paceToMinutes(b);
                });

                sortedPaces.forEach(pace => {
                    const runnersInAssignment = assignments.groups[pace];

                    out_string = pace.split(' ')[0] + ": "
                    first_runner = true

                    if (runnersInAssignment.length > 0) {
                        // Sort runners within the group by seniority
                        const sortedRunnersInGroup = runnersInAssignment.sort((aId, bId) => runnerInputData[aId].seniority - runnerInputData[bId].seniority);

                        const runnersHtml = sortedRunnersInGroup.map(rId => {
                            const runner = runnerInputData[rId];
                            if (first_runner) {
                                out_string += runner.name
                            } else {
                                out_string += ", " + runner.name
                            }

                            return `<span class="inline-block bg-primary/20 text-primary px-2 py-0.5 text-xs font-medium rounded-full m-0.5">${runner.name} (${runner.seniority})</span>`;
                        }).join('');

                        groupsListEl.innerHTML += `
                        <div class="p-4 bg-white shadow rounded-lg border-l-4 border-primary">
                            <p class="font-bold text-md mb-2">${pace} <span class="text-gray-500 font-normal">(${runnersInAssignment.length} runners)</span></p>
                            <div class="flex flex-wrap">${runnersHtml}</div>
                        </div>
                    `;
                    }
                    result_string += out_string + "\n"

                });
            }


            // --- Initialization ---

            window.onload = () => {
                // Add one initial blank runner row on load
                createNewRunnerInData("", 1, [], true);
                switchView('runner'); // Render the default view
                sEl.textContent = 'Status: Ready to configure runners and solve.';
                sEl.className = 'font-bold text-lg mb-4 text-gray-800';
            };

            // Store the ID of the dragged runner
        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
            // Optional: Add a class to the original element to make it appear 'lifted' or semi-transparent
            setTimeout(() => {
                ev.target.style.opacity = '0.4';
            }, 0);
        }

        // Allow the element to be dropped
        function allowDrop(ev) {
            ev.preventDefault();
            // Optional: Highlight the drop zone on drag over (handled by dragEnter/dragLeave)
        }

        // Apply a visual cue when dragging enters a valid drop target
        function dragEnter(ev) {
            if (ev.target.closest('.pace-group')) {
                ev.target.closest('.pace-group').classList.add('drag-over');
            }
        }

        // Remove the visual cue when dragging leaves the drop target
        function dragLeave(ev) {
            if (ev.target.closest('.pace-group')) {
                ev.target.closest('.pace-group').classList.remove('drag-over');
            }
        }

        // Handle the drop event
        function drop(ev) {
            ev.preventDefault();
            const runnerId = ev.dataTransfer.getData("text");
            const runnerElement = document.getElementById(runnerId);

            // Get the drop target, ensuring it is the pace-group div
            const dropTarget = ev.target.closest('.pace-group');

            if (dropTarget) {
                // Find the pace-runners container within the drop target
                const runnerContainer = dropTarget.querySelector('.pace-runners');

                if (runnerContainer) {
                    runnerContainer.appendChild(runnerElement);
                    // Remove the opacity/visual lift from the runner element
                    runnerElement.style.opacity = '1';

                    // Remove the drop zone highlight
                    dropTarget.classList.remove('drag-over');

                    // OPTIONAL: Update runner counts (advanced, not implemented here)
                    // You would need to iterate through all .pace-runners and update the associated .pace-count span.
                }
            }
        }

        // Initialize drag and drop events (for mobile compatibility or general cleanup)
        document.addEventListener('dragend', (ev) => {
            // Revert opacity/styles if drag was cancelled or finished
            if (ev.target.classList.contains('runner-bubble')) {
                ev.target.style.opacity = '1';
            }
            // Clean up highlights in case dragend occurred outside a drop
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        });
        </script>



</div></body></html>
